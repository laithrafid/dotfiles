#!/usr/bin/python3  
import os
import plistlib
import psutil
import subprocess
from tabulate import tabulate
from termcolor import colored
import curses


def get_launchctl_manager_info():
    try:
        result = subprocess.run(['launchctl', 'managerpid'], capture_output=True, text=True)
        managerpid = result.stdout.strip()

        result = subprocess.run(['launchctl', 'manageruid'], capture_output=True, text=True)
        manageruid = result.stdout.strip()

        result = subprocess.run(['launchctl', 'managername'], capture_output=True, text=True)
        managername = result.stdout.strip()

        return managerpid, manageruid, managername

    except subprocess.CalledProcessError:
        return None


def get_process_info(process):
    try:
        managerpid, manageruid, _ = get_launchctl_manager_info()
        gui_command = ['launchctl', 'print', f'gui/{manageruid}/{process}']
        system_command = ['launchctl', 'print', f'system/{process}']

        # Run the GUI command and get the result
        gui_result = subprocess.run(gui_command, capture_output=True, text=True)
        gui_output_lines = gui_result.stdout.strip().split('\n')

        pid = ""
        state = ""
        domain = ""

        for line in gui_output_lines:
            if 'pid =' in line or 'PID =' in line:
                pid = line.split('=', 1)[1].strip()
            elif 'state =' in line:
                state = line.split('=', 1)[1].strip()
            elif 'domain =' in line:
                domain = line.split('=', 1)[1].strip()

        # If PID is found from the GUI command, return the result
        if state:
            return pid, state, domain

        # Run the system command and get the result
        system_result = subprocess.run(system_command, capture_output=True, text=True)
        system_output_lines = system_result.stdout.strip().split('\n')

        pid = ""
        state = ""
        domain = ""

        for line in system_output_lines:
            if 'pid =' in line or 'PID =' in line:
                pid = line.split('=', 1)[1].strip()
            elif 'state =' in line:
                state = line.split('=', 1)[1].strip()
            elif 'domain =' in line:
                domain = line.split('=', 1)[1].strip()

        return pid, state, domain

    except subprocess.CalledProcessError as e:
        print(f"Error running launchctl print for process {process}: {e.stderr}")
        return "", "", ""


def list_config_files(directory):
    config_files = []
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith('.plist'):
                plist_path = os.path.join(root, file)
                config_files.append(plist_path)
    return config_files


def get_plist_info(plist_path):
    with open(plist_path, 'rb') as plist_file:
        plist_data = plist_file.read()
        plist = plistlib.loads(plist_data)
        return plist


def generate_table(progress_bar):
    headers = ["#", "Level", "Directory of Plist", "PID", "Process", "State", "Domain", "Open files by Process"]
    table_data = []

    directories = [
        ("User Agents", os.path.expanduser("~/Library/LaunchAgents")),
        ("Global Agents", "/Library/LaunchAgents"),
        ("Global Daemons", "/Library/LaunchDaemons"),
        ("System Agents", "/System/Library/LaunchAgents"),
        ("System Daemons", "/System/Library/LaunchDaemons")
    ]

    total_files = 0
    completed_files = 0

    # Count total number of files
    for level, directory in directories:
        total_files += len(list_config_files(directory))

    row_number = 1

    for level, directory in directories:
        config_files = list_config_files(directory)
        for plist_path in config_files:
            plist_info = get_plist_info(plist_path)
            process_name = plist_info.get("Label", "")
            process_pid, state, domain = get_process_info(process_name)
            process_open_files = ""

            level_colored = colored(level, "yellow")
            plist_path_colored = colored(plist_path, "cyan")
            process_pid_colored = colored(process_pid, "green") if process_pid else ""
            process_name_colored = colored(process_name, "magenta")
            state_colored = colored(state, "blue") if state else ""
            domain_colored = colored(domain, "blue") if domain else ""
            process_open_files_colored = colored(process_open_files, "blue")

            table_data.append([
                str(row_number),
                level_colored,
                plist_path_colored,
                process_pid_colored,
                process_name_colored,
                state_colored,
                domain_colored,
                process_open_files_colored
            ])

            completed_files += 1

            # Update the progress bar
            progress = int((completed_files / total_files) * 100)
            progress_bar.addstr(0, 0, f"Progress: {progress}%")
            progress_bar.refresh()

            row_number += 1

    return tabulate(table_data, headers=headers, tablefmt="psql")


def print_table(stdscr, table, current_row):
    stdscr.clear()
    height, width = stdscr.getmaxyx()

    lines = table.split('\n')
    table_height = len(lines)

    # Adjust the height to fit within the terminal size
    max_height = height - 2  # Leave one line for input

    # Determine the starting and ending indices of the visible rows
    start_row = max(0, current_row)
    end_row = min(table_height, start_row + max_height)

    # Get the visible portion of the table
    visible_table = lines[start_row:end_row]

    for i, line in enumerate(visible_table):
        stdscr.addstr(i, 0, line[:width-1])  # Trim the line if it exceeds the width

    stdscr.refresh()


def main(stdscr):
    curses.curs_set(0)  # Hide the cursor
    stdscr.nodelay(1)  # Set non-blocking mode for keyboard input

    height, width = stdscr.getmaxyx()
    progress_bar = curses.newwin(1, width, height-1, 0)
    table = generate_table(progress_bar)
    current_row = 0

    while True:
        print_table(stdscr, table, current_row)

        key = stdscr.getch()

        if key == ord('q'):
            break
        elif key == curses.KEY_UP:
            if current_row > 0:
                current_row -= 1
        elif key == curses.KEY_DOWN:
            if current_row < len(table.split('\n')) - 3:
                current_row += 1

        stdscr.refresh()


curses.wrapper(main)
